1 МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ
1.1 Мета роботи

Метою лабораторної роботи є розробка програмного забезпечення для IoT пристою, що є частиною системи для контролю акваріумів, опис прийнятих інженерних рішень, побудова діаграм. Необхідно представити будову системи та її взаємодію з іншими частинами системи.

1.2 Моделювання програмної системи

Задля розгляду функціональності було побудовано Use-Case діаграму (див. А1), що відображає ролі в системі. Наявні дві ролі: датчик, бо є функціонал який виконує датчик самостійно, а також користувач системи, якій може керувати та адмініструвати IoT пристрій.
Щодо розгляду функціональності датчиків, на Use-Case діаграмі (див.  А1) можемо побачити, що кожен датчик має можливість отримувати показники вологості, температури, кислотності, освітлення акваріуму, активності та стану мешканця акваріуму, та надсилати їх на сервер включно із прорахованим рівнем води для отриманого акваріуму, для отриманого акваріуму також встановлюється розклад годування, функціонал для взаємодії з серверною частиною (функції для GET та POST запитів до сервера).
У користувача системи є можливість управління датчиками та додавання нових датчиків, що будуть збирати данні, а також своєї автентифікації задля управління правильним переліком датчиків, що належить саме цьому користувачу. Це також відображено на Use-Case діаграмі (див. А1), а саме: перегляд списку датчиків з їх актувальними даними, додавання та видалення датчиків.
Повний цикл системи можна описати наступним чином:
-	Користувач при першому використанні системи повинен локально підключитися до контролеру для для створення необхідних датчиків та налаштувань типу цих датчиків та їх ідентифікаторів. 
-	Після успішної реєстрації датчиків в системі, система починає виконувати свій функціонал, спочатку система отримує дані з датчиків, далі система перевіряє чи відповідний користувач намагається оновити дані відповідних зареєстрованих датчиків на сервері, отримує відповідний акваріум з серверу на основі якого прораховує поточний рівень води в акваріумі, назначає розклад годування акваріуму, після чого оновлює дані датчиків на сервері, також вказуючи час отримання оновлених даних для кожного з датчиків.
-	При отриманні даних сервером та їх обробці, сервер інтерпритує дані датчику температури в градусах Цельсія, рівня води у сантиметрах, освітлення в Люксах, кислотності в pH, активності мешканця та стану мешканця у відсотках.
-	Після чого дані зберігаються в базі даних та можуть бути використані сервером для подальшої їх обробки та використанні. Цикл наведених кроків буде повторюватись до поки систему не буде вимкнено від живлення.

1.3 Взаємодія між частинами системи

Взаємодія цієї частини з іншими частинами системи відбувається через серверну частину, яка містить необхідні методи для взаємодії, до цих методів належать: метод для автентифікації користувача, щоб підтвердити що сенсор належить саме цьому користувачу, метод для отримання переліку зареєстрованих датчиків користувачем, метод для отримання даних про відповідний акваріум, а також метод для оновлення даних відповідного зареєстрованого датчика, що належить користувачу. 
Як приклад відображення взаємодії було створено діаграму взаємодії на основі діаграми активності щодо обробки даних (див. А3). На цій діаграмі можна докладніше поглянути на послідовність дій власне програми, а також як відбувається взаємодія з серверною частиною.



2 ПРОГРАМНА РЕАЛІЗАЦІЯ
2.1 Архітектура програмної системи

Програмне забезпечення для пристрою IoT було розроблено на мові програмування С++ у симуляторі Wokwi. Для відтворення фізичної системи було використано мікроконтроллер Arduino ESP32, які має можливість підключення до мережі та виходу в Інтернет, що необхідно для взаємодії з серверною частиною, датчик DHT22 для підрахунку вологості та температури, аналогові потенціометри POT для демонстрації можливості відслідковування кислотності акваріуму та показників активності мешканців акваріуму і їх стану, датчик LDR для відслідковування освітлення акваріуму. Також в програмі використовуються HTTP-запити для взаємодії з серверною частиною, бібліотеки HTTpClient для реалізації запитів, NTCClient та TimeLib для роботи з часом, ArduinoJson для обробки відповіді з серверної частини.

2.2 Програмна розробка системи

Перед початком написання коду було створено схему для фізичного розміщення частин системи: контроллера та сенсорів (див. А5). Принцип підключення до контролера полягає в наступному: якщо сенсор DHT22 буде використовуватися для виміру і температури, і вологості, то його необхідно підключати до піна ESP23, всі інші підключення цих сенсорів робляться аналогічно, якщо потенціометр POT буде використовуватись для відображення активності мешканців необхідно підключати до піна ESP33, якщо потенціометр POT буде використовуватись для відображення стану мешканців необхідно підключати до піна ESP32, всі інші підключення цих сенсорів робляться аналогічно, якщо потенціометр POT буде використовуватись для відображення кислотності акваріуму необхідно підключати до піна ESP35, якщо датчик LDR  буде використовуватись для виміру освітлення, то його необхідно підключати до піна ESP34 (всі підключення відбуваються з виходу SDA). Інші виходи сенсора потрібно підключати так: VCC до 3V3, GND до GND.
Після створення схеми фізичного розміщення частин починається написання коду. Спочатку оголошуються глобальні константні змінні, що повинні бути доступні в усіх методах програми. Це змінні номерів пінів підключення сенсорів, параметри мережі, частота надсилання спостережень на серверну частину, HTTP та NTP клієнти, адреса серверної частини.
В методі setup() відбувається налаштування системи. Спочатку аналізуються піни та чи підключені до них датчики, після чого починаються спроби підключитися до мережі.
Після підключення та всіх налаштувань системи починається робота з сервером: в методі loop() кожен сенсор надає дані про значення які він спостеріг, також отримується тип цього сенсора та ідентифікатор акваріуму чи мешканця акваріуму за якими він спростерігає. Далі також відбувається автентифікація користувача, щоб визначити, що датчики належать саме цьому користувачу, якщо автертифікація пройшла успішно, то кожен датчик буде намагатись отримати відповідний собі запис в базі даних для цього користувача, також буде отримання відповідного акваріуму, на основі якого буде розраховано поточний рівень води цього акваріуму, а також встановлено розклад годування для цього акваріуму, далі дачики будуть намагатись оновити дані зареєстрованого користувачем датчика на найбільш актувальні (див. Б2). Увесь функціонал методу loop() буде відбуватися до поки контролер не буде вимкнено, та з встановленою частотою.
Код методу updateSensorData() наведено в додатках (див. Б1 рядок 129). Він створює адресу за якою потрібно створити POST запит до сервера, після цього створюється JSON об’єкт з усіма даними датчика для оновлення сервером, після чого відправляється запит на сервер.
Код методу calculateCurrentWaterLevel() наведено в додатках (див Б3). Він на основі нормальних показників акваріуму та значень датчиків розраховує поточний рівень води в цьому акваріумі.
Код методу getAquariumByType() наведено в додатках (див Б1 рядок 85). Він використовується для створення GET запиту до сервера, щоб отримати JSON об’єкт із відповідним акваріумом.
Код методу getFeedingSchedulesForAquarium() наведено в додатках (див Б1 рядок 167). Він використовується для створення GET запиту до сервера, щоб отримати JSON об’єкт із розкладами годування для відповідного акваріуму.

2.3 Висновки

У результаті виконання цієї лабораторної роботи мною було розроблено програмне забезпечення для пристрою IoT, що є частиною системи для контролю акваріумів, описано архітектуру системи, програмну реалізацію, описано фізичну схему, її взаємодію з іншими частинами системи, створено діаграми.

ПЕРЕЛІК ДЖЕРЕЛ
1.	DEMO відео. URL: 
https://youtu.be/Gj3fswhVXv8?si=OZhRzcDGw8OVFn9E
2.	Репозиторій проекту. URL: https://github.com/NureVolnykovKyrylo/apz-pzpi-21-2-volnykov-kyrylo
3.	Посилання на проект у симуляторі Wokwi. URL:
https://wokwi.com/projects/399124373355034625 
